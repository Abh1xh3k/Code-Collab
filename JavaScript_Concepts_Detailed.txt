JAVASCRIPT INTERVIEW CONCEPTS - QUICK REFERENCE
==============================================

1. ARRAYS AND OBJECTS FUNCTIONS
===============================

KEY ARRAY METHODS:
------------------
let arr = [1, 2, 3, 4, 5];

map()     - transforms elements: arr.map(x => x * 2) → [2, 4, 6, 8, 10]
filter()  - filters elements: arr.filter(x => x > 3) → [4, 5]
reduce()  - reduces to single value: arr.reduce((acc, curr) => acc + curr, 0) → 15
find()    - finds first match: arr.find(x => x > 3) → 4
forEach() - iterates without return

KEY OBJECT METHODS:
-------------------
let obj = { a: 1, b: 2, c: 3 };

Object.keys(obj)    → ['a', 'b', 'c']
Object.values(obj)  → [1, 2, 3]  
Object.entries(obj) → [['a', 1], ['b', 2], ['c', 3]]

DESTRUCTURING:
--------------
let { name, age } = person;  // Object destructuring
let [first, second] = arr;   // Array destructuring

2. DIFFERENCE BETWEEN LET AND VAR
=================================

VAR vs LET:
-----------
                VAR              LET/CONST
Scope:          Function         Block
Hoisting:       Yes (undefined)  Yes (TDZ)
Redeclaration:  Allowed          Not allowed
Reassignment:   Allowed          let: Yes, const: No

EXAMPLES:
---------
// Scope difference
function test() {
    if (true) {
        var a = 1;    // Function scoped
        let b = 2;    // Block scoped
    }
    console.log(a);   // 1 (accessible)
    console.log(b);   // ReferenceError
}

// Hoisting difference
console.log(x);       // undefined
console.log(y);       // ReferenceError (TDZ)
var x = 5;
let y = 10;

3. HOISTING AND TEMPORAL DEAD ZONE (TDZ)
========================================

HOISTING:
---------
JavaScript moves declarations to the top of their scope.

// Function declarations are fully hoisted
console.log(sayHello()); // "Hello!" - works

function sayHello() {
    return "Hello!";
}

// var is hoisted and initialized with undefined
console.log(x); // undefined
var x = 5;

TEMPORAL DEAD ZONE (TDZ):
-------------------------
Period between scope start and declaration where let/const cannot be accessed.

console.log(a); // ReferenceError - TDZ
let a = 1;      // TDZ ends here

4. ILLEGAL SHADOWING
====================

LEGAL vs ILLEGAL:
-----------------
// ✅ Legal - let shadows var in block scope
var a = 1;
{
    let a = 2; // OK
}

// ❌ Illegal - var cannot shadow let in same functional scope
let b = 1;
{
    var b = 2; // SyntaxError
}

RULE: var cannot shadow let/const in the same functional scope.

5. IMMEDIATELY INVOKED FUNCTION EXPRESSION (IIFE)
=================================================

SYNTAX & PURPOSE:
-----------------
(function() {
    // Code here - runs immediately
})();

PURPOSE: Creates private scope, avoids global namespace pollution

COMMON USES:
------------
// Module pattern
let myModule = (function() {
    let privateVar = "private";
    
    return {
        publicMethod: function() {
            return privateVar;
        }
    };
})();

// Variable isolation in loops
for (var i = 0; i < 3; i++) {
    (function(index) {
        setTimeout(() => console.log(index), 100); // 0, 1, 2
    })(i); 
}

6. THIS KEYWORD
===============                              

CONTEXT RULES:
--------------
1. Global context: window/global object  
2. Object method: the object itself  
3. Constructor: new instance
4. Arrow function: inherits from parent scope
5. Event handler: the element

EXAMPLES:
---------
let obj = {
    name: "John",
    regular: function() {
        console.log(this.name); // "John"
    },
    arrow: () => {
        console.log(this.name); // undefined (global context)
    }
};

// Lost context
let detached = obj.regular;
detached(); // undefined (no object context)

7. CALL, APPLY, BIND
====================

PURPOSE: Explicitly set 'this' context

DIFFERENCES:
------------
call()  - Invokes immediately with individual arguments
apply() - Invokes immediately with array of arguments  
bind()  - Returns new function with bound context

EXAMPLES:
---------
function greet(greeting) {
    console.log(`${greeting}, I'm ${this.name}`);
}

let person = { name: "John" };

// call - immediate execution
greet.call(person, "Hello"); // "Hello, I'm John"

// apply - immediate execution with array
greet.apply(person, ["Hi"]); // "Hi, I'm John"

// bind - returns new function
let boundGreet = greet.bind(person);
boundGreet("Hey"); // "Hey, I'm John"

8. CALLBACK HELL
================

PROBLEM: Deeply nested callbacks creating "pyramid of doom"

EXAMPLE:
--------
getData((err, data) => {
    if (!err) {
        processData(data, (err, processed) => {
            if (!err) {
                saveData(processed, (err, result) => {
                    if (!err) {
                        console.log(result);
                    }
                });
            }
        });
    }
});

SOLUTIONS:
----------
1. Named functions
2. Promises  
3. Async/await

9. PROMISES AND CHAINING
========================

STATES: Pending → Fulfilled/Rejected

BASIC USAGE:
------------
let promise = new Promise((resolve, reject) => {
    if (success) resolve("data");
    else reject("error");
});

promise
    .then(result => console.log(result))
    .catch(error => console.log(error))
    .finally(() => console.log("done"));

CHAINING:
---------
getData()
    .then(data => processData(data))
    .then(processed => saveData(processed))
    .then(result => console.log(result))
    .catch(error => console.log(error));

STATIC METHODS:
---------------
Promise.all([p1, p2, p3])     // Wait for all
Promise.race([p1, p2, p3])    // First to settle
Promise.allSettled([p1, p2])  // All settled (success/fail)

10. ASYNC/AWAIT
===============

SYNTAX: Makes async code look synchronous

BASIC USAGE:
------------
async function fetchData() {
    try {
        let response = await fetch('/api/data');
        let data = await response.json();
        return data;
    } catch (error) {
        console.log(error);
    }
}

SEQUENTIAL vs PARALLEL:
-----------------------
// Sequential (slower)
async function sequential() {
    let a = await operation1(); // Wait 1s
    let b = await operation2(); // Wait 1s more
    return [a, b]; // Total: 2s
}

// Parallel (faster)  
async function parallel() {
    let [a, b] = await Promise.all([
        operation1(), 
        operation2()
    ]); // Total: 1s
    return [a, b];
}

11. DEBOUNCING AND THROTTLING
=============================

DEBOUNCING: Execute function only after delay period of inactivity
THROTTLING: Execute function at most once per time period

DEBOUNCE:
---------
function debounce(func, delay) {
    let timeoutId;
    return function(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => func.apply(this, args), delay);
    };
}

// Usage: Search input
let debouncedSearch = debounce(searchAPI, 500);

THROTTLE:
---------
function throttle(func, limit) {
    let inThrottle;
    return function(...args) {
        if (!inThrottle) {
            func.apply(this, args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
        }
    };
}

// Usage: Scroll events
let throttledScroll = throttle(handleScroll, 100);

USE CASES:
----------
Debouncing: Search input, API calls, resize events
Throttling: Scroll events, mouse movement, rate limiting

12. EVENT PROPAGATION
=====================

THREE PHASES:
-------------
1. Capturing: Root → Target
2. Target: At the element
3. Bubbling: Target → Root (default)

EXAMPLE:
--------
<div id="parent">
    <button id="child">Click</button>
</div>

// Bubbling (default)
parent.addEventListener('click', () => console.log('Parent'));
child.addEventListener('click', () => console.log('Child'));
// Output when button clicked: Child → Parent

// Capturing (3rd parameter = true)
parent.addEventListener('click', () => console.log('Parent'), true);
// Output: Parent → Child

STOPPING PROPAGATION:
---------------------
event.stopPropagation();          // Stops further propagation
event.stopImmediatePropagation(); // Stops other listeners on same element
event.preventDefault();           // Prevents default browser behavior

EVENT DELEGATION:
-----------------
// Handle events for multiple elements efficiently
parent.addEventListener('click', (event) => {
    if (event.target.matches('.button')) {
        console.log('Button clicked');
    }
});

KEY PROPERTIES:
---------------
event.target        // Element that triggered event
event.currentTarget // Element with the listener
event.type          // Event type (click, keydown, etc.)

===================================================
INTERVIEW TIP: Focus on understanding concepts rather than memorizing syntax.
Practice with real examples and be able to explain the "why" behind each concept!